(in-package :skyline-tool)

(defun read-map-labels (&optional (pathname #p"./Object/Bank00.Public.NTSC.o.LABELS.txt"))
  (with-input-from-file (label-file pathname :if-does-not-exist :error)
    (loop for line = (read-line label-file nil nil)
          while line
          for (label$ addr$) = (split-sequence #\= line)
          for label = (string-trim #(#\Space) label$)
          for addr = (cond
                       ((and (char= (char (string-trim #(#\Space) addr$) 0) #\$)
                             (every (rcurry #'member
                                            '(#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9 #\a #\b #\c #\d #\e #\f)
                                            :test #'char-equal)
                                    (subseq (string-trim #(#\Space #\$) addr$) 1)))
                        (parse-integer (string-trim #(#\Space #\$) addr$)
                                       :radix 16))
                       ((every (rcurry #'member
                                       '(#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
                                       :test #'char=)
                               (string-trim #(#\Space) addr$))
                        (parse-integer (string-trim #(#\Space) addr$))))
          when (and label (numberp addr) (< 5 (length label)) (search "Map" label))
            collect (cons label addr))))

(defun decode-attributes-block (bytes &optional dump)
  (labels ((splain-bit (byte bit label &optional more)
             (when (plusp (logand (ash 1 bit) (elt bytes byte)))
               (format t "~&~10t~a" label)
               (when more
                 (funcall more)))))
    (format t "~&~8tBytes: ~{$~2,'0x~^ ~}" (coerce bytes 'list))
    (splain-bit 0 0 "WallNorth")
    (splain-bit 0 1 "WallSouth")
    (splain-bit 0 2 "WallWest")
    (splain-bit 0 3 "WallEast")
    (splain-bit 0 4 "WallUnderNorth")
    (splain-bit 0 5 "WallUnderSouth")
    (splain-bit 0 6 "WallUnderWest")
    (splain-bit 0 7 "WallUnderEast")
    (splain-bit 1 0 "Ceiling")
    (splain-bit 1 1 "Wade")
    (splain-bit 1 2 "Swim")
    (splain-bit 1 3 "Climb")
    (splain-bit 1 4 "Pit")
    (splain-bit 1 5 "Door")
    (splain-bit 1 6 "Flammable")
    (splain-bit 1 7 "StairsDown")
    (splain-bit 2 0 "Ice")
    (splain-bit 2 1 "Fire")
    (when (= #x04 (logand #x0c (elt bytes 2)))
      (format t "~&~10tStepTrigger"))
    (when (= #x08 (logand #x0c (elt bytes 2)))
      (format t "~&~10tPullTrigger"))
    (when (= #x0c (logand #x0c (elt bytes 2)))
      (format t "~&~10tPushTrigger"))
    (splain-bit 2 4 "Iron")
    (splain-bit 2 5 "XXX undefined byte 2 bit 5")
    (splain-bit 2 6 "XXX undefined byte 2 bit 6")
    (splain-bit 2 7 "Exit"
                (lambda ()
                  (if dump
                      (let ((ref (1- (logand #x1f (elt bytes 4)))))
                        (format t "~&~12tExit reference ID: ~d
~14tExit to locale $~2,'0x (~a) at (~d, ~d)"
                                ref
                                (elt dump (+ 0 (* 3 ref) #x7c00))
                                (car (find-if (lambda (pair) (= (cdr pair) (elt dump (+ 0 (* 3 ref) #x7c00))))
                                              (read-map-labels)))
                                (elt dump (+ 1 (* 3 ref) #x7c00))
                                (elt dump (+ 2 (* 3 ref) #x7c00))))
                      (let ((ref (logand #x1f (elt bytes 5))))
                        (format t "~&~12tExit reference ID: ~d (no decode available)" ref)))))
    (when (plusp (logand #x07 (elt bytes 3)))
      (format t "~&~10tSpeed: ~d" (logand #x07 (elt bytes 3))))
    (when (= #x10 (logand #x30 (elt bytes 3)))
      (format t "~&~10tPushable (normal weight)"))
    (when (= #x20 (logand #x30 (elt bytes 3)))
      (format t "~&~10tPushable (heavy weight)"))
    (when (= #x30 (logand #x30 (elt bytes 3)))
      (format t "~&~10tPushable (very heavy weight)"))
    (splain-bit 3 6 "XXX unused byte 3 bit 6")
    (splain-bit 3 7 "Script"
                (lambda ()
                  (format t "~&~12tScript reference ID: ~d" (elt bytes 5))))
    (format t "~&~10tPalette: ~d" (ash (logand #xe0 (elt bytes 4)) -5))))

(defun decode-map-attributes (x y &optional (dump (load-dump-into-mem)))
  (let ((addresses (read-map-labels)))
    (labels ((addr-of (field)
               (cdr (assoc field addresses :test #'string=)))
             (fetch (field)
               (elt dump (addr-of field)))
             (get-tile-attr-id (x y)
               (logand #x7f (elt dump (+ (addr-of "MapTileAttributes") x (* y (fetch "MapWidth"))))))
             (attribute-addr (id)
               (+ (addr-of "MapAttributes") (* 6 id)))
             (get-attributes (id)
               (let ((start (attribute-addr id)))
                 (subseq dump start (+ 6 start)))))
      (assert (and (<= 0 x) (< x (fetch "MapWidth"))) (x)
              "Map width is ~:d tile~:p, x (~:d) is outside of map" (fetch "MapWidth") x)
      (assert (and (<= 0 y) (< y (fetch "MapHeight"))) (y)
              "Map height is ~:d tile~:p, y (~:d) is outside of map" (fetch "MapHeight") y)
      (let* ((attr-id (get-tile-attr-id x y))
             (attributes (get-attributes attr-id)))
        (format t "~2&Decoding tile at (~d, ~d): attribute ID $~2,'0x (~:*~d) at $~4,'0x"
                x y attr-id (attribute-addr attr-id))
        (decode-attributes-block attributes dump)))))

(defun decode-all-attributes (&optional (dump (load-dump-into-mem)))
  (fresh-line) (terpri)
  (let ((addresses (read-map-labels)))
    (labels ((addr-of (field)
               (cdr (assoc field addresses :test #'string=))))
      (loop for i from 0
            for bytes = (subseq dump
                                (+ (* 6 i) (addr-of "MapAttributes"))
                                (+ (* 6 (1+ i)) (addr-of "MapAttributes")))
            when (and (plusp i) (every #'zerop bytes))
              do (return)
            do (progn
                 (format t "~%ATTR # $~2,'0x (~:*~d)" i)
                 (decode-attributes-block bytes dump))))))

(defun decode-map (&optional (dump (load-dump-into-mem)))
  (let ((addresses (read-map-labels)))
    (labels
        ((addr-of (field)
           (cdr (assoc field addresses :test #'string=)))
         (fetch (field)
           (elt dump (addr-of field))))
      (assert (= #x7000 (addr-of "MapArt")))
      (format t "~2&Locale name: ~a (~a, $~2,'0x)"
              (minifont->unicode (subseq dump
                                         (1+ (addr-of "MapNameString"))
                                         (+ 1 (addr-of "MapNameString") (fetch "MapNameString"))))
              (fetch "CurrentMap")
              (fetch "CurrentMap"))
      (format t "~2&Map currently ~d Ã— ~d tiles:" (fetch "MapWidth") (fetch "MapHeight"))
      (let ((n (fetch "MapBackground"))
            (pals (addr-of "MapPalettes")))
        (format t "~&Background color: $~2,'0x  ~a" n (atari-colu-string n))
        (format t "~&Palettes: ~{$~2,'0x, $~2,'0x, $~2,'0x~32t~a, ~a, ~a~^~%~10t~}"
                (loop for i below 8
                      appending (let ((c1 (elt dump (+ (* 3 i) pals)))
                                      (c2 (elt dump (+ 1 (* 3 i) pals)))
                                      (c3 (elt dump (+ 2 (* 3 i) pals))))
                                  (list c1 c2 c3
                                        (atari-colu-string c1)
                                        (atari-colu-string c2)
                                        (atari-colu-string c3))))))
      (dotimes (y (fetch "MapHeight"))
        (format t "~%[ART]")
        (dotimes (x (fetch "MapWidth"))
          (let* ((art-code (elt dump (+ x (* y (fetch "MapWidth")) (addr-of "MapArt"))))
                 (tile-id (logand #x7f art-code))
                 (headp (= #x80 (logand #x80 art-code))))
            (format t "~:[ ~;/~]~2,'0x" headp tile-id)))
        (format t "~%{ATR}")
        (dotimes (x (fetch "MapWidth"))
          (let* ((attr-code (elt dump (+ x (* y (fetch "MapWidth")) (addr-of "MapTileAttributes"))))
                 (attr-id attr-code))
            (format t " ~2,'0x" attr-id))))))
  (decode-all-attributes dump))

(defun show-map ()
  "Decode the map from a core dump."
  (clim-simple-echo:run-in-simple-echo #'decode-map
                                       :width 1111
                                       :height 1111
                                       :process-name "Map from Core Dump"))

